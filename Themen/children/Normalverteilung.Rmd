

name: teila
class: center, middle, inverse



# Verteilungen

---

## Häufigkeitsverteilung

.pull-left[
  
Die Verteilung eines *diskreten* Merkmals $X$ mit $k$ Ausprägungen zeigt, wie häufig die einzelnen Ausprägungen sind.
  
  
```{r Normalverteilung-1, echo = TRUE}
  data(mtcars)
  mtcars %>% 
    count(cyl)
```
  
]

.pull-right[
  
Ein *stetiges* Merkmal lässt sich durch Klassenbildung diskretisieren:
    
```{r Normalverteilung-2}
  mtcars %>% 
    ggplot(aes(x = hp)) +
    geom_histogram()
```
  
]


---

## Wahrscheinlichkeitsverteilung


Eine *diskrete* Wahrscheinlichkeitsverteilung des Merkmals $X$ ordnet jeder der $k$ Ausprägungen $X=x$ eine Wahrscheinlichkeit $p$ zu. So hat die Variable *Geschlecht eines Babies* die beiden Ausprägungen *Mädchen* und *Junge* mit den Wahrscheinlichkeiten $p_M = 51.2\%$ bzw. $p_J = 48.8\%$ 
`r RefManageR::Citep(bib, "gelman_regression_2021")`.

Bei *stetigen* Merkmalen $X$ geht man von unendlich vielen Ausprägungen aus; die Wahrscheinlichkeit einer bestimmten Ausprägung ist (praktisch) Null: $p(X=x_j)=0, \quad j=1,...,k$. Daher gibt man stattdessen die *Dichte* der Wahrscheinlichkeit an: Das ist die Wahrscheinlichkeit(smasse) pro eine Einheit von $X$.


---

## Beispiele für  Wahrscheinlichkeitsdichte


.pull-left[

```{r Normalverteilung-3}
ggplot(data = data.frame(x = c(-3, 3)), aes(x)) +
  stat_function(fun = dnorm, n = 101, args = list(mean = 0, sd = 1)) +
  labs(y = "Dichte", x = "Merkmal, X")
```

Bei $X=0$ hat eine Einheit von $X$ die Wahrscheinlichkeitsmasse von 40%.

]

.pull-right[

```{r Normalverteilung-4, fig.asp = 0.5}
#source: https://dk81.github.io/dkmathstats_site/rmath-uniform-plots.html

uniform_Plot <- function(a, b){
  xvals <- data.frame(x = c(a, b)) #Range for x-values
  
  ggplot(data.frame(x = xvals), 
         aes(x = x)) + xlim(c(a, b)) + ylim(0, 1/(b - a)) +
    stat_function(fun = dunif, args = list(min = a, max = b), 
                  geom = "area", 
                  fill = "green", alpha = 0.35) + 
    stat_function(fun = dunif, args = list(min = a, max = b)) +
    labs(x = "X", y = "Dichte")  +
    geom_vline(xintercept = a, linetype = "dashed", colour = "red") +
    geom_vline(xintercept = b, linetype = "dashed", colour = "red")
  
}

uniform_Plot(-1, 1)
uniform_Plot(0, 3)
```
Bei $X=0$ hat eine Einheit von $X$ die Wahrscheinlichkeitsmasse von 50% bzw. 33%.

]

---

## Gesetz der großen Zahl


Zieht man (zufällig) immer mehr Werte aus einer Verteilung (mit endlichem Mittelwert), nähert sich der Mittelwert der Stichprobe immer mehr mit dem Mittelwert (oft als Erwartungswert bezeichnet) der Verteilung an 
`r RefManageR::Citep(bib, "taleb2019technical")`



```{r Normalverteilung-5, out.width = "100%", fig.align="center", fig.asp = .5}
source(paste0(here::here(),"/R-Code/img15.R"))
```


---


## Normal auf dem Fußballfeld

Sie und 1000 Ihrer besten Freunde stehen auf der Mittellinie eines Fußballfelds (eng). Auf Kommando werfen alle jeweils eine Münze; bei Kopf geht man einen Schritt nach links, bei Zahl nach rechts. Das wird 16 Mal wiederholt. Wie wird die Verteilung der Positionen wohl aussehen?


```{r Normalverteilung-6, fig.asp = .5, fig.width=7}
source(paste0(here::here(),"/R-Code/img13.R"))

```


---

## Normal durch Addieren

Die Summe vieler (gleich starker) Zufallswerte (aus der gleichen Verteilung) erzeugt eine Normalverteilung; egal aus welcher Verteilung die Zufallswerte kommen (Zentraler Grenzwertsatz).


```{r Normalverteilung-7, out.width="100%", fig.asp = 0.5, fig.align="center", fig.width=7}
source(paste0(here::here(),"/R-Code/img14.R"))
```


---


## Nicht verwechseln

```{r Normalverteilung-8, echo = FALSE, out.width="30%", fig.align='center'}
knitr::include_graphics("https://github.com/sebastiansauer/QM2-Folien/raw/main/img/ch33910f1.jpg")
```

`r RefManageR::Citep(bib, "freeman_visual_2006")`


---

## Normalverteilung vs. randlastige Verteilungen


```{r Normalverteilung-9, fig.asp=0.5}
ggplot(data = data.frame(x = c(-3, 3)), aes(x)) +
  stat_function(fun = dnorm, n = 101, args = list(mean = 0, sd = 1), color = "blue") +
  labs(y = "Dichte", x = "Merkmal, X") +
  stat_function(fun = dt, n = 101, args = list(df = 1, ncp =0), color = "red") +
  labs(caption = "Blau: Normalverteilung\nRot: randlastige Verteilung (t-Verteilung mit df=1)")
```


Bei randlastigen Verteilungen ("fat tails") kommen Extremereignisse viel häufiger vor als bei Normalverteilungen. Deshalb ist es wichtig sein, zu wissen, ob eine Normalverteilung oder eine randlastige Verteilung vorliegt. Viele statistische Methoden sind nicht zuverlässig bei (stark) randlastigen Methoden 
`r RefManageR::Citep(bib, "taleb2019technical")`


---

## Beispiele für Normal- und randlastige Verteilungen


.pull-left[

### Normal verteilt

- Größe 
- Münzwürfe
- Gewicht
- IQ
- Blutdruck
- Ausschuss einer Maschine
]

.pull-right[

### Randlastig verteilt

- Vermögen
- Verkaufte Bücher
- Ruhm
- Aktienkurse
- Erdbeben
- Pandemien
- Kriege
- Erfolg auf Tinder
- Meteroritengröße
- Stadtgrößen
]

---


## Formel der Normalverteilung

Vereinfacht ausgedrückt lässt die Normalverteilung $\mathcal{N}$ durch Exponenzieren einer Quadratfunktion beschreiben:

$$\mathcal{N} \propto e^{-x^2}$$

mit $e=2.71...$, der Eulerschen Zahl.

.pull-left[


```{r norm, eval = FALSE, echo = TRUE}
d <-
  tibble(
    x = seq(-3, 3, 
            length.out = 100),
    y = exp(-x^2)
  )

d %>% 
  ggplot() +
  aes(x = x, y = y) +
  geom_line()
```

]

.pull-right[

```{r Normalverteilung-10, echo = FALSE, ref.label = "norm"}
```

]

Die Normalverteilung wird auch *[Gauss](https://de.wikipedia.org/wiki/Carl_Friedrich_Gau%C3%9F)-Verteilung* oder *Glockenkurve* genannt.

---

## Normalverteilung als konservative Wahl


.left-column[
</br>
</br>
</br>
</br>
</br>

```{r, echo = FALSE} 
knitr::include_graphics("https://upload.wikimedia.org/wikipedia/commons/f/f8/10_Deutsche_Mark_-_detail.png")
```

.tiny[Uni Greifswald, Public domain, via Wikimedia Commons]
]


.right-column[

### Ontologische Begründung

- Wirken viele, gleichstarke Einflüsse additiv zusammen, entsteht eine Normalverteilung  `r RefManageR::Citep(bib, "mcelreath_statistical_2020")`, Kap. 4.1.4.

### Epistemologische Begründung

- Wenn wir nur wissen, dass eine Variable über einen endlichen Mittelwert und eine endliche Varianz verfügt und wir keine weiteren Annahmen treffen bzw. über kein weiteres Vorwissen verfügen, dann ist die Normalverteilung die plausibelste Verteilung (maximale Entropie) `r RefManageR::Citep(bib, "mcelreath_statistical_2020")`, Kap. 7 und 10.

]

---

## Zweidimensionale Normalverteilung, unkorreliert


```{r Normalverteilung-11, out.width="70%", fig.align="center"}
knitr::include_graphics("https://github.com/sebastiansauer/QM2-Folien/raw/main/img/mult-norm.png")
```


.tiny[[Quelle](https://tex.stackexchange.com/questions/31708/draw-a-bivariate-normal-distribution-in-tikz)]

.footnote[[Vgl. auch dieses Diagramm](http://ballistipedia.com/index.php?title=File:Bivariate.png)]

---


## 2D-Normalverteilung mit R, unkorreliert

$r(X,Y) = 0$



.pull-left[
```{r norm-plot1, echo = TRUE, eval = FALSE}
d1 <- 
  tibble( 
    x=rnorm(1e4), 
    y=rnorm(1e4)
  )

ggplot(d1) +
  aes(x, y) +
  geom_hex() 

ggplot(d1) +
  aes(x, y) +
  geom_density2d()
```

.tiny[[ggplot-Referenz](https://ggplot2.tidyverse.org/reference/geom_density_2d.html), [Quellcode](https://www.r-graph-gallery.com/2d-density-plot-with-ggplot2.html)]

Mit `scale_fill_continuous(type = "viridis")`kann man die Farbpalette der Füllfarbe ändern.
]


.pull-right[

```{r echo = FALSE}
d1 <- 
  tibble( 
    x=rnorm(1e4), 
    y=rnorm(1e4)
  )

ggplot(d1) +
  aes(x, y) +
  geom_hex() +
  scale_fill_viridis_c()

ggplot(d1) +
  aes(x, y) +
  geom_density2d()
```


]

---

## 2D-Normalverteilung mit R, korreliert, r=0.7




.pull-left[

Die ersten paar Zeilen der Daten:

```{r echo = FALSE}
library(faux)

d2 <- rnorm_multi(
  n = 1e4,
  mu = c(0,0),
  sd = c(1, 1),
  r = (0.7)
)
```

```{r}
d2 %>% 
  head(n=3) %>% 
  gt() %>% 
  fmt_number(columns = everything())
```

Berechnen wir die Korrelation `r`:

```{r echo = TRUE, eval = FALSE}
d2 %>% 
  summarise(
    r = cor(X1,X2),
    n = n()
  )
```

```{r}
d2 %>% 
  summarise(
    r = cor(X1,X2),
    n = n()
  ) %>% 
  gt() %>% 
  fmt_number(columns = everything())
```


]

.pull-right[

```{r}
ggplot(d2) +
  aes(X1, X2) +
  geom_hex() +
  scale_fill_viridis_c()

ggplot(d2) +
  aes(X1, X2) +
  geom_density2d()
```

]


---
